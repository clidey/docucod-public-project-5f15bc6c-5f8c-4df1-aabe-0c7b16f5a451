---
title: "Variables and Environment Handling"
description: "Learn how Task supports variables and environment management—allowing parameterization and reuse within your tasks. See how variables are defined, referenced, and how Task blends system environment variables with those defined in your Taskfile for flexible, context-aware automation."
---

# Variables and Environment Handling

Task empowers your automation workflows through flexible variable and environment management. This page explains how Task lets you define, reference, and blend variables and environment variables to create dynamic, reusable tasks that adapt to your context effortlessly.

---

## Why Variables and Environment Matter

When automating repetitive commands or complex builds, you need your tasks to be configurable yet predictable. Variables provide this by allowing you to parameterize commands inside your Taskfile, while environment variables extend this flexibility across the system and shell context. Task seamlessly merges these layers so your workflows stay concise but powerful.

Imagine running the same build process across different platforms or adjusting deployments by switching API keys without modifying your entire Taskfile. Variables and environment handling make this possible — crafting customizable and context-aware automation.

---

## Understanding Variables in Task

### What Are Variables?
Variables are key-value pairs defined within your Taskfile or dynamically generated by shell commands. They allow you to insert customizable values into commands, arguments, or other variables through Go-template interpolation.

Variables can be defined globally in the Taskfile, at the task level, or even passed inline when invoking a task, enabling fine-grained control over execution.

### Defining Variables
You define variables in the `vars` section:

```yaml
version: '3'

vars:
  GREETING: 'Hello'
  TARGET: 'World'
tasks:
  greet:
    cmds:
      - echo "{{.GREETING}}, {{.TARGET}}!"
```

Output:
```
Hello, World!
```

### Dynamic Variables with Shell Commands
Variables can be dynamically assigned using shell commands:

```yaml
vars:
  CURRENT_USER:
    sh: echo $USER

tasks:
  whoami:
    cmds:
      - echo "Current user: {{.CURRENT_USER}}"
```

This runs the shell command once and caches the output for use as the variable value.

### Variable Usage in Tasks
Within tasks, variables can be overridden or added:

```yaml
tasks:
  build:
    vars:
      VERSION: '1.2.3'
    cmds:
      - echo "Building version {{.VERSION}}"
```

Passing variables at call-time:

```bash
task build VERSION=2.0.0
```

This overrides the variable for that specific task execution.

---

## How Environment Variables Work in Task

Task integrates system environment variables alongside your Taskfile-defined variables to maintain consistency and extend configuration possibilities.

### Two Ways to Define Environment Variables
- **`env` Section:** Defines environment variables to be set during task execution. This affects the shell environment in which commands run.
- **System Environment:** Variables from the user’s shell or OS environment are available automatically.

### Example:

```yaml
vars:
  PATH_PREFIX: '/usr/local/bin'
env:
  PATH: '{{.PATH_PREFIX}}:{{.PATH}}'

tasks:
  show-path:
    cmds:
      - echo "PATH is $PATH"
```

This configures the `PATH` environment variable for the task by prepending `PATH_PREFIX`.

### Variable Precedence and Merging
Task merges variables and environment variables in the following order (highest precedence last):

1. System environment variables (e.g., `PATH`, `HOME`)
2. `env` variables defined in the Taskfile
3. Variables defined in `vars` sections
4. Inline variables passed at task invocation

This layered approach ensures environment variables can override or extend variables when necessary.

---

## Variable Scope and Inheritance

Variables and environments can be scoped at different levels for granular control:

- **Global scope:** Variables and env defined globally at the root of the Taskfile
- **Task scope:** Variables and env defined inside an individual task
- **Included Taskfiles and Dotenv:** Imported Taskfiles and Dotenv files contribute variables, inheriting according to context and can be overridden

This enables capturing defaults globally, but tailoring behavior in specific tasks.

### Dotenv Support for Environment Variables

Task supports reading `.env` files using the `dotenv` key, blending their variables into your environment, supporting real-world workflows where environment secrets or config are managed outside Taskfiles.

```yaml
dotenv:
  - '.env'

tasks:
  run:
    cmds:
      - echo "Running with API_KEY=$API_KEY"
```

If `.env` contains `API_KEY=secret`, this becomes available to tasks.

---

## Special and Automatic Variables

Task provides a set of special environment variables always available to tasks:

| Variable         | Description                              |
|------------------|--------------------------------------|
| `TASK`           | Name of the current task              |
| `ALIAS`          | Alias used for the task invocation    |
| `TASK_EXE`       | Path to Task executable                |
| `ROOT_TASKFILE`  | Absolute path of the main Taskfile    |
| `ROOT_DIR`       | Directory containing the root Taskfile|
| `TASKFILE`       | Absolute path of the current Taskfile |
| `TASKFILE_DIR`   | Directory of the current Taskfile     |
| `TASK_DIR`       | Directory where the task executes     |
| `USER_WORKING_DIR` | Directory where Task was called      |
| `TASK_VERSION`   | Current Task version                   |

These variables help in dynamic pathing, task introspection, logging, and advanced templating.

---

## Templating with Variables

Variables can be templated and manipulated with powerful templating functions powered by Go’s `text/template` and Task’s extended function library.

Example:

```yaml
tasks:
  example:
    vars:
      MSG: 'Hello World'
      MSG_LOWER: '{{.MSG | lower}}'
    cmds:
      - echo '{{.MSG_LOWER}}'
```

Output:
```
hello world
```

Advanced templating enables conditionals, loops, string formatting, and more, helping you adapt commands precisely to your needs.

---

## Common Use Cases and Examples

### Parameterizing Commands Across Environments

```yaml
vars:
  ENV: 'development'
  API_URLS:
    map:
      development: 'https://dev.api'
      production: 'https://api'

tasks:
  call:
    cmds:
      - curl '{{index .API_URLS .ENV}}/endpoint'
```

Run with:

```bash
task call ENV=production
```

This switches API endpoints dynamically.

### Combining System and Task Environments

Use system environment variables seamlessly:

```yaml
env:
  HOME_DIR: '{{.HOME}}'

tasks:
  print-home:
    cmds:
      - echo "User home is $HOME_DIR"
```

### Overriding Variables in Included Taskfiles and Tasks

You can override variables from included Taskfiles or parent tasks by redefining them in your task or when calling a subtask.

---

## Best Practices

- **Create descriptive variable names** to avoid conflicts and improve readability.
- **Use variables for paths, versions, flags, and secrets** to centralize configuration.
- **Prefer `env` for environment variables your scripts depend on at runtime**.
- **Cache dynamic variables sparingly** to avoid stale values but reduce overhead.
- **Leverage Dotenv support for sensitive or environment-specific variables**, keeping them out of Taskfiles.
- **Use templating functions to normalize input and format outputs** for robust command generation.

---

## Troubleshooting Tips

- If variables aren’t interpolating, check for correct syntax `{{.VAR_NAME}}` and that they are properly defined.
- Ensure shell commands in dynamic variables do not produce errors — inspect verbose logs.
- Remember environment variables passed from your shell override Taskfile variables unless explicitly overridden.
- Use `task --verbose` to log variable resolution and command execution details.

---

## Getting Started with Variables and Environment

To begin:

1. Define your global variables under `vars` in the Taskfile.
2. Use `env` to specify environment variables for tasks that require a customized shell environment.
3. Experiment with dynamic variables using shell commands for runtime computed values.
4. Use Dotenv files for managing secrets or environment-specific configs.
5. Use templating in commands with `{{.VAR_NAME}}` to insert variable values.
6. Pass variables inline when running tasks to override defaults temporarily.

For a deeper dive, see the [Variables and Environment Management in Task](../guides/advanced-features-patterns/variables-envs) guide.

---

## Summary

Variables and environment handling in Task let you build flexible, extensible automation workflows by blending static, dynamic, and system environment data. Use variables to parameterize behavior, environment variables to customize runtime shell contexts, and templating functions to shape command execution. With scoped variables, Dotenv support, and special variables provided automatically, Task streamlines both simple and complex automation needs with confidence.

---

## Related Documentation

- [What is Task?](../product-intro/what-is-task) — Learn about Task fundamentals.
- [Tasks and the Taskfile](../core-concepts/tasks-and-taskfiles) — Understand task structure and organization.
- [Templating Reference](../../reference/templating) — Explore Task’s powerful templating syntax and functions.
- [Variables and Environment Management in Task (Guide)](../../guides/advanced-features-patterns/variables-envs) — In-depth patterns and examples.
- [Dotenv Support](../core-concepts/variables-and-environment#dotenv-support) — Using .env files.
- [Environment Reference](../../reference/environment) — Task-specific environment variables.

---

For practical use, start by defining your project variables and environment in your Taskfile, template your commands, and incrementally enhance your tasks with dynamic variables and environment overrides.


